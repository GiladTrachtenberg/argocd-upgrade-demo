#!/bin/bash
#
# ApplicationSet Validation Script
#
# This script validates that the ApplicationSet migration was successful
# and all generated Applications are working correctly.
#
# Usage:
#   ./validate-applicationset.sh
#

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Counters
PASS=0
FAIL=0
WARN=0

# Functions
print_header() {
    echo -e "\n${BLUE}===================================${NC}"
    echo -e "${BLUE}$1${NC}"
    echo -e "${BLUE}===================================${NC}\n"
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
    ((PASS++))
}

print_failure() {
    echo -e "${RED}✗${NC} $1"
    ((FAIL++))
}

print_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
    ((WARN++))
}

print_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

# Validation checks
check_applicationset_exists() {
    print_header "1. Checking ApplicationSet Exists"

    if kubectl get applicationset test-apps -n argocd &>/dev/null; then
        print_success "ApplicationSet 'test-apps' exists in argocd namespace"
        return 0
    else
        print_failure "ApplicationSet 'test-apps' not found"
        return 1
    fi
}

check_applicationset_conditions() {
    print_header "2. Checking ApplicationSet Conditions"

    local conditions
    conditions=$(kubectl get applicationset test-apps -n argocd -o json | jq -r '.status.conditions[]? | "\(.type)=\(.status)"' 2>/dev/null)

    if [ -z "$conditions" ]; then
        print_warning "No conditions found on ApplicationSet (may still be initializing)"
        return 0
    fi

    echo "$conditions" | while read -r condition; do
        print_info "Condition: $condition"
    done
    print_success "ApplicationSet has status conditions"
}

check_generated_applications() {
    print_header "3. Checking Generated Applications"

    local apps
    apps=$(kubectl get applications -n argocd -l demo.managed-by=applicationset -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)

    if [ -z "$apps" ]; then
        print_failure "No Applications generated by ApplicationSet"
        print_info "Expected Applications with label: demo.managed-by=applicationset"
        return 1
    fi

    local app_count
    app_count=$(echo "$apps" | wc -w | tr -d ' ')
    print_success "Found $app_count Applications generated by ApplicationSet"

    for app in $apps; do
        print_info "  - $app"
    done

    return 0
}

check_application_sync_status() {
    print_header "4. Checking Application Sync Status"

    local apps
    apps=$(kubectl get applications -n argocd -l demo.managed-by=applicationset -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)

    if [ -z "$apps" ]; then
        print_warning "No Applications to check sync status"
        return 0
    fi

    local all_synced=true
    for app in $apps; do
        local sync_status
        sync_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null)

        if [ "$sync_status" = "Synced" ]; then
            print_success "Application '$app' is Synced"
        else
            print_warning "Application '$app' sync status: ${sync_status:-Unknown}"
            all_synced=false
        fi
    done

    if [ "$all_synced" = false ]; then
        print_info "Some applications may still be syncing (this is normal)"
    fi
}

check_application_health_status() {
    print_header "5. Checking Application Health Status"

    local apps
    apps=$(kubectl get applications -n argocd -l demo.managed-by=applicationset -o jsonpath='{.items[*].metadata.name}' 2>/dev/null)

    if [ -z "$apps" ]; then
        print_warning "No Applications to check health status"
        return 0
    fi

    for app in $apps; do
        local health_status
        health_status=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null)

        case "$health_status" in
            "Healthy")
                print_success "Application '$app' is Healthy"
                ;;
            "Progressing")
                print_info "Application '$app' is Progressing (syncing resources)"
                ;;
            "Degraded")
                print_failure "Application '$app' is Degraded"
                ;;
            "Missing")
                print_warning "Application '$app' health status: Missing"
                ;;
            *)
                print_warning "Application '$app' health status: ${health_status:-Unknown}"
                ;;
        esac
    done
}

check_old_app_of_apps_removed() {
    print_header "6. Checking Legacy App-of-Apps Removal"

    if kubectl get application app-of-apps -n argocd &>/dev/null; then
        print_warning "Legacy app-of-apps Application still exists"
        print_info "Consider removing: kubectl delete application app-of-apps -n argocd"
    else
        print_success "Legacy app-of-apps Application has been removed"
    fi

    if [ -f "/Users/giladtrachtenberg/work/scripts/argocd/upgrade/test-apps/app-of-apps/application.yaml" ]; then
        print_warning "Old app-of-apps file still exists without .deprecated suffix"
    else
        print_success "Old app-of-apps file properly renamed to .deprecated"
    fi
}

check_project_exists() {
    print_header "7. Checking AppProject"

    if kubectl get appproject test-apps -n argocd &>/dev/null; then
        print_success "AppProject 'test-apps' exists"
        return 0
    else
        print_failure "AppProject 'test-apps' not found"
        print_info "Deploy with: kubectl apply -f test-apps/project.yaml"
        return 1
    fi
}

check_namespaces_created() {
    print_header "8. Checking Application Namespaces"

    local apps
    apps=$(kubectl get applications -n argocd -l demo.managed-by=applicationset -o json 2>/dev/null | \
           jq -r '.items[]? | .spec.destination.namespace' | sort -u)

    if [ -z "$apps" ]; then
        print_warning "No Applications found to check namespaces"
        return 0
    fi

    for ns in $apps; do
        if kubectl get namespace "$ns" &>/dev/null; then
            print_success "Namespace '$ns' exists"
        else
            print_warning "Namespace '$ns' does not exist yet (may be created on sync)"
        fi
    done
}

check_applicationset_controller() {
    print_header "9. Checking ApplicationSet Controller"

    if kubectl get deployment argocd-applicationset-controller -n argocd &>/dev/null; then
        local ready
        ready=$(kubectl get deployment argocd-applicationset-controller -n argocd -o jsonpath='{.status.conditions[?(@.type=="Available")].status}' 2>/dev/null)

        if [ "$ready" = "True" ]; then
            print_success "ApplicationSet controller is running and available"
        else
            print_failure "ApplicationSet controller is not available"
            print_info "Check logs: kubectl logs -n argocd -l app.kubernetes.io/name=argocd-applicationset-controller"
        fi
    else
        print_warning "ApplicationSet controller deployment not found"
        print_info "This might be expected if using an older Argo CD version"
    fi
}

print_summary() {
    print_header "Validation Summary"

    local total=$((PASS + FAIL + WARN))

    echo -e "Total Checks: $total"
    echo -e "${GREEN}Passed: $PASS${NC}"
    echo -e "${YELLOW}Warnings: $WARN${NC}"
    echo -e "${RED}Failed: $FAIL${NC}"

    echo ""

    if [ $FAIL -eq 0 ] && [ $WARN -eq 0 ]; then
        echo -e "${GREEN}========================================${NC}"
        echo -e "${GREEN}ApplicationSet Migration: SUCCESS${NC}"
        echo -e "${GREEN}========================================${NC}"
        return 0
    elif [ $FAIL -eq 0 ]; then
        echo -e "${YELLOW}========================================${NC}"
        echo -e "${YELLOW}ApplicationSet Migration: SUCCESS (with warnings)${NC}"
        echo -e "${YELLOW}========================================${NC}"
        return 0
    else
        echo -e "${RED}========================================${NC}"
        echo -e "${RED}ApplicationSet Migration: INCOMPLETE${NC}"
        echo -e "${RED}========================================${NC}"
        return 1
    fi
}

print_next_steps() {
    print_header "Next Steps"

    echo "1. Deploy ApplicationSet (if not already deployed):"
    echo "   kubectl apply -k /Users/giladtrachtenberg/work/scripts/argocd/upgrade/test-apps/"
    echo ""
    echo "2. Watch Applications being created:"
    echo "   watch kubectl get applications -n argocd -l demo.managed-by=applicationset"
    echo ""
    echo "3. View ApplicationSet status:"
    echo "   kubectl describe applicationset test-apps -n argocd"
    echo ""
    echo "4. Check ApplicationSet controller logs:"
    echo "   kubectl logs -n argocd -l app.kubernetes.io/name=argocd-applicationset-controller -f"
    echo ""
    echo "5. Sync all Applications:"
    echo "   argocd app sync -l demo.managed-by=applicationset"
    echo ""
}

# Main execution
main() {
    echo -e "${BLUE}"
    echo "╔═══════════════════════════════════════════════╗"
    echo "║   ApplicationSet Migration Validator         ║"
    echo "║   Argo CD Upgrade Demo Environment          ║"
    echo "╚═══════════════════════════════════════════════╝"
    echo -e "${NC}"

    # Run validation checks
    check_applicationset_exists || true
    check_project_exists || true
    check_applicationset_controller || true
    check_applicationset_conditions || true
    check_generated_applications || true
    check_application_sync_status || true
    check_application_health_status || true
    check_namespaces_created || true
    check_old_app_of_apps_removed || true

    # Print summary
    print_summary
    local exit_code=$?

    # Print next steps
    print_next_steps

    exit $exit_code
}

# Check prerequisites
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}Error: kubectl not found${NC}"
    echo "Please install kubectl to run this validation script"
    exit 1
fi

if ! command -v jq &> /dev/null; then
    echo -e "${YELLOW}Warning: jq not found${NC}"
    echo "Some checks may not work correctly without jq"
    echo "Install with: brew install jq (macOS) or apt-get install jq (Linux)"
    echo ""
fi

# Run main
main
